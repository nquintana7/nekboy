package memory;

import cpu.*;
import cpu.Timer;
import graphic.*;

import javax.swing.*;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

public class MMU {
	private boolean left_boot;
	private final int vram_offset = 0x8000;
	private final int oam_offset = 0xFE00;
	private final int wram_offet = 0xC000;
	private final int hram_offet = 0xFF80;
	public final int[] wram, hram, vram, oam, io;
	private int[] rom;
	public int[] boot_rom;
	private Timer tm;
	private InterruptsController ic;
	private boolean DMA_intransfer;
	private int DMA_counter;
	public int pad_state;
	public boolean action;
	public Joypad joy;

	public MMU(InterruptsController ic, Timer tmeru, Joypad j) throws IOException {
		left_boot = true;
		oam = new int[160];
		vram = new int[8192];
		hram = new int[127];
		wram = new int[8192];
		io = new int[128];
		loadROM();
		loadBootROM();
		this.ic = ic;
		tm = tmeru;
		DMA_intransfer = false;
		pad_state = 0xff;
		joy = j;
	}
	
	public int getByte (int addr) {
		addr = addr&0xffff;
		if(addr >= 0 && addr<=0x3fff) {
			if(left_boot) {
				return rom[addr]&0xff;
			} else {
				if(addr < 0x0100) {
					return boot_rom[addr] & 0xff;
				} else {
					return rom[addr]&0xff;
				}
			}
		} else if(addr >0x3fff && addr <= 0x7fff) {
				return rom[addr];
		} else if(addr > 0x7fff && addr <= 0x9fff) {
				return vram[addr-vram_offset]&0xff;
		} else if (addr >= 0xc000 && addr <=0xdfff) {
				return wram[addr-wram_offet]&0xff;
		} else if(addr >= 0xfe00 && addr <= 0xfe9f) {
			return oam[addr - oam_offset] & 0xff;
		} else if(addr == 0xff00) {
			return joy.getByte();
		} else if(addr>0xff00 && addr <=0xff7f) {
			if(addr == 0xFF04) {
				return tm.DIV&0xff;
			} else if(addr == 0xff0f) {
				return ic.getIF();
			} else if(addr == 0xFF05) {
				return tm.TIMA&0xff;
			} else if(addr == 0xFF06) {
				return tm.TMA&0xff;
			} else if(addr == 0xFF07) {
				return tm.TAC&0xff;
			} else if(addr == 0xFF40) {
				return io[addr-0xFF00]&0xff;
			} else {
				return io[addr-0xFF00]&0xff;
			}
		} else if(addr>=0xff80 && addr <= 0xfffe) {
			 return hram[addr-hram_offet]&0xff;
		} else if(addr==0xffff) {
			return ic.getIE();
		}
		return 0;
	}

	public void writeByte (int addr, int value) {
		addr = addr&0xffff;
		value = value&0xff;
		if(DMA_intransfer) {
			if(addr>=0xff80 && addr <= 0xfffe) {
				hram[addr - hram_offet] = value;
			}
			return;
		}
		if(addr == 0xff00) {
			joy.writeByte(value&0xff);
			return;
		}
		if ((addr == 0xFF50) && (value != 0)) { //unmap bios
			left_boot = true;
			return;
		}
		if(addr >= 0 && addr<=0x3fff) {
		} else if(addr >0x3fff && addr <= 0x7fff) {
			// return  rom.getByte(addr);
		} else if(addr > 0x7fff && addr <= 0x9fff) {
			vram[addr-vram_offset]=value&0xff;
		} else if (addr >= 0xc000 && addr <=0xdfff) {
			wram[addr-wram_offet] = value&0xff;
		} else if(addr >= 0xfe00 && addr <= 0xfe9f) {
				oam[addr-oam_offset]=value&0xff;
		} else if(addr>0xff00 && addr <=0xff7f) {
			if(addr == 0xFF04) {
				tm.writeToDiv();
			} else if (addr == 0xff0f) {
				ic.writeIF(value);
			} else if(addr == 0xFF05) {
				tm.writeToTIMA(value&0xff);
			} else if(addr == 0xFF06) {
				tm.writeToTMA(value&0xff);
			} else if(addr == 0xFF07) {
				tm.writeToTac(value&0xff);
			} else if(addr == 0xFF40) {
				io[addr-0xFF00] = (value&0xff)|1<<7;
			} else if(addr == 0xff46) {
				int address = (value<<8)&0xffff; // source address is data * 100
				for (int i = 0 ; i < 0xA0; i++)
				{
					writeByte(0xFE00+i,getByte(address+i)); ;
				}
			} else if(addr == 0xff41) {
				io[addr-0xff00] = (value&0b1111000)&(0xff&io[addr-0xff00]);
			} else if(addr==0xff44) {
				return;
			}else{
			io[addr - 0xFF00] = value & 0xff;
				}
		} else if(addr>=0xff80 && addr <= 0xfffe) {
			hram[addr-hram_offet] = value;
		} else if(addr==0xffff) {
			ic.writeIE(value);
		}
	}
	public void DMA_count (int cycles) {
		if(DMA_intransfer)  {
			DMA_counter+=cycles;
			if(DMA_counter >=(160)) {
				DMA_intransfer = false;
				DMA_counter = 0;
			}
		}
	}

	private void loadROM() throws IOException{
		File file = new File("nekboyproject/cpu_instrs/individual/tetris.gb");
		byte[] bytes = new byte[(int) file.length()];
		rom = new int[(int)file.length()];
		FileInputStream fis = new FileInputStream(file);
		fis.read(bytes);
		fis.close();
		for(int i = 0; i<rom.length;i++) {
			rom[i] = ((int)bytes[i])&0xff;
		}
	}

	private void loadBootROM() {
		boot_rom = new int[]{
				0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
				0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
				0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
				0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
				0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
				0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
				0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
				0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
				0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xE2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
				0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
				0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
				0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
				0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
				0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3C, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x3C,
				0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x00, 0x00, 0x23, 0x7D, 0xFE, 0x34, 0x20,
				0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x00, 0x00, 0x3E, 0x01, 0xE0, 0x50
		};
	}
}
